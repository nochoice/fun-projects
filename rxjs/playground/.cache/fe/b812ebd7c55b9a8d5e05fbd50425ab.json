{"id":"../../node_modules/rxjs/internal/scheduler/AsyncScheduler.js","dependencies":[{"name":"C:\\Users\\koraarom\\Documents\\nochoice\\fun-projects\\node_modules\\rxjs\\internal\\scheduler\\AsyncScheduler.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\koraarom\\Documents\\nochoice\\fun-projects\\node_modules\\rxjs\\src\\internal\\scheduler\\AsyncScheduler.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\koraarom\\Documents\\nochoice\\fun-projects\\package.json","includedInParent":true,"mtime":1590495110095},{"name":"C:\\Users\\koraarom\\Documents\\nochoice\\fun-projects\\node_modules\\rxjs\\package.json","includedInParent":true,"mtime":1590495017965},{"name":"../Scheduler","loc":{"line":16,"column":26},"parent":"C:\\Users\\koraarom\\Documents\\nochoice\\fun-projects\\node_modules\\rxjs\\internal\\scheduler\\AsyncScheduler.js","resolved":"C:\\Users\\koraarom\\Documents\\nochoice\\fun-projects\\node_modules\\rxjs\\internal\\Scheduler.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Scheduler_1 = require(\"../Scheduler\");\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler_1.Scheduler.now; }\n        var _this = _super.call(this, SchedulerAction, function () {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        }) || this;\n        _this.actions = [];\n        _this.active = false;\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return _super.prototype.schedule.call(this, work, delay, state);\n        }\n    };\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n"},"sourceMaps":{"js":{"version":3,"file":"AsyncScheduler.js","sources":["../../src/internal/scheduler/AsyncScheduler.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,0CAAyC;AAMzC;IAAoC,kCAAS;IAmB3C,wBAAY,eAA8B,EAC9B,GAAiC;QAAjC,oBAAA,EAAA,MAAoB,qBAAS,CAAC,GAAG;QAD7C,YAEE,kBAAM,eAAe,EAAE;YACrB,IAAI,cAAc,CAAC,QAAQ,IAAI,cAAc,CAAC,QAAQ,KAAK,KAAI,EAAE;gBAC/D,OAAO,cAAc,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;aACtC;iBAAM;gBACL,OAAO,GAAG,EAAE,CAAC;aACd;QACH,CAAC,CAAC,SACH;QA1BM,aAAO,GAA4B,EAAE,CAAC;QAOtC,YAAM,GAAY,KAAK,CAAC;QAQxB,eAAS,GAAQ,SAAS,CAAC;;IAWlC,CAAC;IAEM,iCAAQ,GAAf,UAAmB,IAAmD,EAAE,KAAiB,EAAE,KAAS;QAA5B,sBAAA,EAAA,SAAiB;QACvF,IAAI,cAAc,CAAC,QAAQ,IAAI,cAAc,CAAC,QAAQ,KAAK,IAAI,EAAE;YAC/D,OAAO,cAAc,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;SAC7D;aAAM;YACL,OAAO,iBAAM,QAAQ,YAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;SAC3C;IACH,CAAC;IAEM,8BAAK,GAAZ,UAAa,MAAwB;QAE5B,IAAA,sBAAO,CAAS;QAEvB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrB,OAAO;SACR;QAED,IAAI,KAAU,CAAC;QACf,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QAEnB,GAAG;YACD,IAAI,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,EAAE;gBACtD,MAAM;aACP;SACF,QAAQ,MAAM,GAAG,OAAO,CAAC,KAAK,EAAE,EAAE;QAEnC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QAEpB,IAAI,KAAK,EAAE;YACT,OAAO,MAAM,GAAG,OAAO,CAAC,KAAK,EAAE,EAAE;gBAC/B,MAAM,CAAC,WAAW,EAAE,CAAC;aACtB;YACD,MAAM,KAAK,CAAC;SACb;IACH,CAAC;IACH,qBAAC;AAAD,CAAC,AAjED,CAAoC,qBAAS,GAiE5C;AAjEY,wCAAc","sourcesContent":["import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n"]}},"error":null,"hash":"7071648f00c3f60a69273f716dca55b3","cacheData":{"env":{}}}